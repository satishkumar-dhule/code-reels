/**
 * Voice Interview Session System
 * 
 * Sessions are built from related questions that form a coherent topic.
 * Each session contains 4-6 questions that progress from basic to advanced.
 * 
 * Session Flow:
 * 1. User selects a session topic
 * 2. Questions are presented in order (easy â†’ hard)
 * 3. Each question expects a focused 1-2 sentence answer
 * 4. Immediate feedback with weighted critical point matching
 * 5. Session summary with overall score
 */

import type { Question } from '../types';

// ============================================
// TYPES
// ============================================

export interface VoiceSession {
  id: string;
  topic: string;
  description: string;
  channel: string;
  difficulty: string;
  questionIds: string[];
  totalQuestions: number;
  estimatedMinutes: number;
}

/**
 * Critical point - a key concept with weight
 * Must be at least 2 words for meaningful comparison
 */
export interface CriticalPoint {
  phrase: string;           // At least 2-word phrase (e.g., "load balancer", "eventual consistency")
  weight: number;           // Weight 1-3 (1=nice-to-have, 2=important, 3=critical)
  alternatives: string[];   // Alternative phrasings that count as a match
}

export interface SessionQuestion {
  id: string;
  question: string;
  criticalPoints: CriticalPoint[];  // Weighted critical points for evaluation
  idealAnswer: string;              // The ideal answer for practice mode
  difficulty: string;
  order: number;
}

export interface SessionAnswer {
  questionId: string;
  userAnswer: string;
  score: number;                    // 0-100
  pointsCovered: { phrase: string; weight: number }[];
  pointsMissed: { phrase: string; weight: number }[];
  weightedScore: number;            // Score based on weights
  maxPossibleScore: number;         // Total weight possible
  isCorrect: boolean;               // Score >= 60
  feedback: string;
}

export interface SessionResult {
  sessionId: string;
  topic: string;
  answers: SessionAnswer[];
  overallScore: number;
  verdict: 'excellent' | 'good' | 'needs-work' | 'review-topic';
  summary: string;
  strengths: string[];
  areasToImprove: string[];
  completedAt: string;
}

export interface SessionState {
  session: VoiceSession;
  questions: SessionQuestion[];
  currentQuestionIndex: number;
  answers: SessionAnswer[];
  startedAt: string;
  status: 'intro' | 'in-progress' | 'completed';
}

// ============================================
// SESSION LOADING
// ============================================

let cachedSessions: VoiceSession[] = [];

/**
 * Load pre-built voice sessions
 * Sessions are generated by the session-builder-bot and exported to JSON
 */
export async function loadVoiceSessions(): Promise<VoiceSession[]> {
  if (cachedSessions.length > 0) return cachedSessions;
  
  try {
    const response = await fetch('/data/voice-sessions.json');
    if (!response.ok) {
      console.warn('Voice sessions file not found, will generate from questions');
      return [];
    }
    
    const data = await response.json();
    cachedSessions = data.sessions || [];
    return cachedSessions;
  } catch (e) {
    console.error('Failed to load voice sessions:', e);
    return [];
  }
}

/**
 * Get sessions for a specific channel
 */
export async function getSessionsByChannel(channel: string): Promise<VoiceSession[]> {
  const sessions = await loadVoiceSessions();
  return sessions.filter(s => s.channel === channel);
}

/**
 * Build session questions from question data
 */
export function buildSessionQuestions(
  session: VoiceSession,
  questions: Question[]
): SessionQuestion[] {
  const sessionQuestions: SessionQuestion[] = [];
  
  for (let i = 0; i < session.questionIds.length; i++) {
    const questionId = session.questionIds[i];
    const question = questions.find(q => q.id === questionId);
    
    if (question) {
      const keywords = question.voiceKeywords || [];
      
      // Build critical points from keywords with weights
      const criticalPoints = buildCriticalPoints(keywords);
      
      // Build ideal answer from the question's answer field
      const idealAnswer = buildIdealAnswer(question.answer, keywords);
      
      sessionQuestions.push({
        id: question.id,
        question: question.question,
        criticalPoints,
        idealAnswer,
        difficulty: question.difficulty,
        order: i + 1
      });
    }
  }
  
  return sessionQuestions;
}

/**
 * Build critical points from keywords with weights
 * First keyword gets weight 3 (critical), next 2 get weight 2 (important), rest get weight 1
 */
function buildCriticalPoints(keywords: string[]): CriticalPoint[] {
  const points: CriticalPoint[] = [];
  
  for (let i = 0; i < keywords.length; i++) {
    const keyword = keywords[i];
    
    // Assign weight: first = 3, next 2 = 2, rest = 1
    const weight = i === 0 ? 3 : i <= 2 ? 2 : 1;
    
    // Generate alternatives for the keyword
    const alternatives = generateAlternatives(keyword);
    
    points.push({
      phrase: keyword,
      weight,
      alternatives
    });
  }
  
  return points;
}

/**
 * Generate alternative phrasings for a keyword
 */
function generateAlternatives(keyword: string): string[] {
  const kw = keyword.toLowerCase();
  const alts: string[] = [];
  
  const synonyms: Record<string, string[]> = {
    'kubernetes': ['k8s', 'kube', 'container orchestration'],
    'load balancer': ['lb', 'load balancing', 'traffic distribution'],
    'database': ['db', 'data store', 'datastore'],
    'availability': ['uptime', 'high availability', 'ha'],
    'latency': ['response time', 'delay', 'lag'],
    'throughput': ['bandwidth', 'capacity', 'requests per second'],
    'microservices': ['micro services', 'microservice', 'service-oriented'],
    'authentication': ['auth', 'authn', 'login'],
    'authorization': ['authz', 'permissions', 'access control'],
    'caching': ['cache', 'cached', 'in-memory'],
    'replication': ['replicate', 'replica', 'copies'],
    'sharding': ['shard', 'partitioning', 'horizontal partition'],
    'monitoring': ['monitor', 'observability', 'metrics'],
    'deployment': ['deploy', 'release', 'rollout'],
    'scalability': ['scale', 'scaling', 'scalable'],
    'consistency': ['consistent', 'data consistency'],
    'idempotency': ['idempotent', 'safe to retry'],
    'ci/cd': ['continuous integration', 'continuous deployment', 'pipeline'],
    'eventual consistency': ['eventually consistent', 'async consistency'],
    'strong consistency': ['strongly consistent', 'immediate consistency'],
    'horizontal scaling': ['scale out', 'scaling horizontally'],
    'vertical scaling': ['scale up', 'scaling vertically'],
    'api gateway': ['gateway', 'api management'],
    'message queue': ['queue', 'message broker', 'mq'],
    'rate limiting': ['throttling', 'rate limit'],
    'circuit breaker': ['circuit breaking', 'fail fast'],
    'service mesh': ['mesh', 'sidecar proxy'],
    'container': ['docker', 'containerized'],
    'orchestration': ['orchestrator', 'orchestrating']
  };
  
  // Add synonyms if available
  if (synonyms[kw]) {
    alts.push(...synonyms[kw]);
  }
  
  // Add plural/singular variations
  if (kw.endsWith('s') && kw.length > 3) {
    alts.push(kw.slice(0, -1));
  } else if (!kw.endsWith('s')) {
    alts.push(kw + 's');
  }
  
  // Add hyphenated/non-hyphenated variations
  if (kw.includes('-')) {
    alts.push(kw.replace(/-/g, ' '));
  } else if (kw.includes(' ')) {
    alts.push(kw.replace(/ /g, '-'));
  }
  
  return alts;
}

/**
 * Build a concise ideal answer from the full answer
 */
function buildIdealAnswer(answer: string, keywords: string[]): string {
  if (!answer) return '';
  
  // Split into sentences
  const sentences = answer.split(/[.!?]+/).filter(s => s.trim().length > 10);
  
  if (sentences.length === 0) return answer.trim();
  
  // Find sentences containing keywords
  const keywordLower = keywords.map(k => k.toLowerCase());
  const relevantSentences = sentences.filter(sentence => 
    keywordLower.some(kw => sentence.toLowerCase().includes(kw))
  );
  
  // Take first 2 relevant sentences, or first 2 sentences if none match
  const selectedSentences = relevantSentences.length > 0 
    ? relevantSentences.slice(0, 2) 
    : sentences.slice(0, 2);
  
  return selectedSentences.map(s => s.trim()).join('. ') + '.';
}

// ============================================
// ANSWER EVALUATION
// ============================================

/**
 * Evaluate a session question answer using weighted critical points
 * Each critical point has a weight (1-3) and alternatives for matching
 */
export function evaluateSessionAnswer(
  userAnswer: string,
  sessionQuestion: SessionQuestion
): SessionAnswer {
  const normalizedAnswer = userAnswer.toLowerCase().trim();
  const { criticalPoints } = sessionQuestion;
  
  const pointsCovered: { phrase: string; weight: number }[] = [];
  const pointsMissed: { phrase: string; weight: number }[] = [];
  
  let weightedScore = 0;
  let maxPossibleScore = 0;
  
  // Check each critical point
  for (const point of criticalPoints) {
    const phraseLower = point.phrase.toLowerCase();
    maxPossibleScore += point.weight;
    
    // Direct match
    if (normalizedAnswer.includes(phraseLower)) {
      pointsCovered.push({ phrase: point.phrase, weight: point.weight });
      weightedScore += point.weight;
      continue;
    }
    
    // Check alternatives
    const altMatch = point.alternatives.some(alt => 
      normalizedAnswer.includes(alt.toLowerCase())
    );
    
    if (altMatch) {
      pointsCovered.push({ phrase: point.phrase, weight: point.weight });
      weightedScore += point.weight;
    } else {
      pointsMissed.push({ phrase: point.phrase, weight: point.weight });
    }
  }
  
  // Calculate percentage score based on weighted points
  const baseScore = maxPossibleScore > 0 
    ? (weightedScore / maxPossibleScore) * 100 
    : 50;
  
  // Bonus for additional relevant terms (max 10 points)
  const bonusTerms = findBonusTerms(normalizedAnswer, criticalPoints.map(p => p.phrase));
  const bonus = Math.min(bonusTerms.length * 3, 10);
  
  // Penalty for very short answers
  const wordCount = normalizedAnswer.split(/\s+/).length;
  const lengthPenalty = wordCount < 5 ? 15 : wordCount < 8 ? 5 : 0;
  
  const score = Math.min(100, Math.max(0, Math.round(baseScore + bonus - lengthPenalty)));
  const isCorrect = score >= 60;
  
  // Generate feedback
  const feedback = generateFeedback(score, pointsCovered, pointsMissed);
  
  return {
    questionId: sessionQuestion.id,
    userAnswer,
    score,
    pointsCovered,
    pointsMissed,
    weightedScore,
    maxPossibleScore,
    isCorrect,
    feedback
  };
}

function findBonusTerms(answer: string, expectedPhrases: string[]): string[] {
  // Technical terms that show deeper understanding
  const bonusTerms = [
    'scalability', 'availability', 'reliability', 'latency', 'throughput',
    'consistency', 'partition', 'replication', 'sharding', 'caching',
    'load balancer', 'microservices', 'distributed', 'fault tolerance',
    'monitoring', 'logging', 'alerting', 'sla', 'slo', 'sli',
    'kubernetes', 'docker', 'ci/cd', 'deployment', 'rollback'
  ];
  
  const found: string[] = [];
  const expectedLower = expectedPhrases.map(k => k.toLowerCase());
  
  for (const term of bonusTerms) {
    if (answer.includes(term) && !expectedLower.includes(term)) {
      found.push(term);
    }
  }
  
  return found;
}

function generateFeedback(
  score: number,
  covered: { phrase: string; weight: number }[],
  missed: { phrase: string; weight: number }[]
): string {
  // Sort missed by weight (highest first)
  const sortedMissed = [...missed].sort((a, b) => b.weight - a.weight);
  const missedPhrases = sortedMissed.map(p => p.phrase);
  
  if (score >= 80) {
    return "Excellent! You covered the key concepts well.";
  } else if (score >= 60) {
    if (missedPhrases.length > 0) {
      return `Good answer! Also consider: ${missedPhrases.slice(0, 2).join(', ')}.`;
    }
    return "Good answer with the main points covered.";
  } else if (score >= 40) {
    return `Partial answer. Key terms to include: ${missedPhrases.slice(0, 3).join(', ')}.`;
  } else {
    return `Review this topic. Focus on: ${missedPhrases.slice(0, 3).join(', ')}.`;
  }
}

// ============================================
// SESSION MANAGEMENT
// ============================================

/**
 * Start a new voice session
 */
export function startSession(
  session: VoiceSession,
  questions: SessionQuestion[]
): SessionState {
  return {
    session,
    questions,
    currentQuestionIndex: 0,
    answers: [],
    startedAt: new Date().toISOString(),
    status: 'intro'
  };
}

/**
 * Begin answering questions
 */
export function beginSession(state: SessionState): SessionState {
  return {
    ...state,
    status: 'in-progress'
  };
}

/**
 * Get current question
 */
export function getCurrentQuestion(state: SessionState): SessionQuestion | null {
  if (state.status === 'completed') return null;
  return state.questions[state.currentQuestionIndex] || null;
}

/**
 * Submit answer and move to next question or complete
 */
export function submitAnswer(
  state: SessionState,
  userAnswer: string
): SessionState {
  const currentQuestion = state.questions[state.currentQuestionIndex];
  if (!currentQuestion) return state;
  
  const evaluation = evaluateSessionAnswer(userAnswer, currentQuestion);
  const newAnswers = [...state.answers, evaluation];
  
  const isLastQuestion = state.currentQuestionIndex >= state.questions.length - 1;
  
  return {
    ...state,
    answers: newAnswers,
    status: isLastQuestion ? 'completed' : 'in-progress'
  };
}

/**
 * Move to next question
 */
export function nextQuestion(state: SessionState): SessionState {
  if (state.currentQuestionIndex >= state.questions.length - 1) {
    return { ...state, status: 'completed' };
  }
  
  return {
    ...state,
    currentQuestionIndex: state.currentQuestionIndex + 1
  };
}

/**
 * Calculate final session results
 */
export function completeSession(state: SessionState): SessionResult {
  const { session, answers } = state;
  
  // Calculate overall score using weighted scoring
  const totalWeightedScore = answers.reduce((sum, a) => sum + a.weightedScore, 0);
  const totalMaxScore = answers.reduce((sum, a) => sum + a.maxPossibleScore, 0);
  const overallScore = totalMaxScore > 0 
    ? Math.round((totalWeightedScore / totalMaxScore) * 100) 
    : 0;
  
  // Determine verdict
  let verdict: SessionResult['verdict'];
  if (overallScore >= 80) verdict = 'excellent';
  else if (overallScore >= 60) verdict = 'good';
  else if (overallScore >= 40) verdict = 'needs-work';
  else verdict = 'review-topic';
  
  // Collect missed points (sorted by weight)
  const allMissed = answers.flatMap(a => a.pointsMissed);
  const sortedMissed = allMissed.sort((a, b) => b.weight - a.weight);
  const uniqueMissedPhrases = Array.from(new Set(sortedMissed.map(p => p.phrase)));
  
  // Collect covered points
  const allCovered = answers.flatMap(a => a.pointsCovered);
  const uniqueCoveredPhrases = Array.from(new Set(allCovered.map(p => p.phrase)));
  
  // Generate strengths
  const strengths: string[] = [];
  const correctCount = answers.filter(a => a.isCorrect).length;
  
  if (correctCount === answers.length) {
    strengths.push("Perfect score - all questions answered correctly!");
  } else if (correctCount >= answers.length * 0.7) {
    strengths.push(`Strong performance: ${correctCount}/${answers.length} correct`);
  }
  
  // Count high-weight points covered
  const highWeightCovered = allCovered.filter(p => p.weight >= 2).length;
  if (highWeightCovered >= 3) {
    strengths.push(`Covered ${highWeightCovered} critical concepts`);
  }
  
  if (uniqueCoveredPhrases.length >= 5) {
    strengths.push(`Good coverage: ${uniqueCoveredPhrases.slice(0, 4).join(', ')}`);
  }
  
  // Generate areas to improve
  const areasToImprove: string[] = [];
  
  // Prioritize high-weight missed points
  const highWeightMissed = sortedMissed.filter(p => p.weight >= 2);
  if (highWeightMissed.length > 0) {
    const criticalMissed = highWeightMissed.slice(0, 3).map(p => p.phrase);
    areasToImprove.push(`Critical concepts to review: ${criticalMissed.join(', ')}`);
  } else if (uniqueMissedPhrases.length > 0) {
    areasToImprove.push(`Review: ${uniqueMissedPhrases.slice(0, 5).join(', ')}`);
  }
  
  const lowScoreCount = answers.filter(a => a.score < 50).length;
  if (lowScoreCount > 0) {
    areasToImprove.push(`${lowScoreCount} question(s) need more practice`);
  }
  
  // Generate summary
  const summary = generateSessionSummary(overallScore, correctCount, answers.length, session.topic);
  
  return {
    sessionId: session.id,
    topic: session.topic,
    answers,
    overallScore,
    verdict,
    summary,
    strengths,
    areasToImprove,
    completedAt: new Date().toISOString()
  };
}

function generateSessionSummary(
  score: number,
  correct: number,
  total: number,
  topic: string
): string {
  if (score >= 80) {
    return `Excellent understanding of ${topic}! You answered ${correct}/${total} questions correctly.`;
  } else if (score >= 60) {
    return `Good grasp of ${topic}. ${correct}/${total} correct. Keep practicing!`;
  } else if (score >= 40) {
    return `Basic understanding of ${topic} (${correct}/${total}). Review the missed concepts.`;
  } else {
    return `${topic} needs more study. Score: ${correct}/${total}. Review fundamentals.`;
  }
}

// ============================================
// FALLBACK: GENERATE SESSIONS FROM QUESTIONS
// ============================================

/**
 * Generate sessions from questions when pre-built sessions aren't available
 * Groups questions by subChannel and creates coherent sessions
 */
export function generateSessionsFromQuestions(questions: Question[]): VoiceSession[] {
  const sessions: VoiceSession[] = [];
  
  // Filter voice-suitable questions
  const suitable = questions.filter(q => 
    q.voiceSuitable === true && 
    q.voiceKeywords && 
    q.voiceKeywords.length >= 3
  );
  
  // Group by channel + subChannel
  const groups: Record<string, Question[]> = {};
  
  for (const q of suitable) {
    const key = `${q.channel}:${q.subChannel}`;
    if (!groups[key]) groups[key] = [];
    groups[key].push(q);
  }
  
  // Create sessions from groups with 4+ questions
  for (const [key, groupQuestions] of Object.entries(groups)) {
    if (groupQuestions.length < 4) continue;
    
    const [channel, subChannel] = key.split(':');
    
    // Sort by difficulty
    const sorted = groupQuestions.sort((a, b) => {
      const order: Record<string, number> = { beginner: 0, intermediate: 1, advanced: 2 };
      return (order[a.difficulty] || 1) - (order[b.difficulty] || 1);
    });
    
    // Take 4-6 questions
    const sessionQuestions = sorted.slice(0, 6);
    
    // Determine overall difficulty
    const difficulties = sessionQuestions.map(q => q.difficulty);
    const difficulty = difficulties.includes('advanced') ? 'advanced' :
                      difficulties.includes('intermediate') ? 'intermediate' : 'beginner';
    
    sessions.push({
      id: `gen-${channel}-${subChannel}-${Date.now()}`,
      topic: formatTopic(subChannel),
      description: `Practice session covering ${subChannel} concepts`,
      channel,
      difficulty,
      questionIds: sessionQuestions.map(q => q.id),
      totalQuestions: sessionQuestions.length,
      estimatedMinutes: sessionQuestions.length * 2
    });
  }
  
  return sessions;
}

function formatTopic(subChannel: string): string {
  return subChannel
    .replace(/-/g, ' ')
    .replace(/\b\w/g, c => c.toUpperCase());
}

// ============================================
// STORAGE HELPERS
// ============================================

const SESSION_STATE_KEY = 'voice-session-state';
const SESSION_HISTORY_KEY = 'voice-session-history';

export function saveSessionState(state: SessionState): void {
  try {
    localStorage.setItem(SESSION_STATE_KEY, JSON.stringify(state));
  } catch (e) {
    console.error('Failed to save session state:', e);
  }
}

export function loadSessionState(): SessionState | null {
  try {
    const saved = localStorage.getItem(SESSION_STATE_KEY);
    return saved ? JSON.parse(saved) : null;
  } catch (e) {
    console.error('Failed to load session state:', e);
    return null;
  }
}

export function clearSessionState(): void {
  try {
    localStorage.removeItem(SESSION_STATE_KEY);
  } catch (e) {
    console.error('Failed to clear session state:', e);
  }
}

export function saveSessionToHistory(result: SessionResult): void {
  try {
    const history = getSessionHistory();
    history.unshift(result);
    localStorage.setItem(SESSION_HISTORY_KEY, JSON.stringify(history.slice(0, 20)));
  } catch (e) {
    console.error('Failed to save session to history:', e);
  }
}

export function getSessionHistory(): SessionResult[] {
  try {
    const saved = localStorage.getItem(SESSION_HISTORY_KEY);
    return saved ? JSON.parse(saved) : [];
  } catch (e) {
    console.error('Failed to load session history:', e);
    return [];
  }
}
