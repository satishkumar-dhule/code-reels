/**
 * Test System - Quiz functionality for knowledge assessment
 * Tests are generated by test-bot per module with 25-50 questions
 * Each test session offers 20 random questions
 */

export interface TestOption {
  id: string;
  text: string;
  isCorrect: boolean;
}

export interface TestQuestion {
  id: string;
  questionId: string; // Reference to original question
  question: string;
  type: 'single' | 'multiple'; // single choice or multiple answer
  options: TestOption[];
  explanation?: string;
  difficulty: 'beginner' | 'intermediate' | 'advanced';
}

export interface Test {
  id: string;
  channelId: string;
  channelName: string;
  title: string;
  description: string;
  questions: TestQuestion[];
  passingScore: number; // percentage
  timeLimit?: number; // minutes, optional
  createdAt: string;
  version: number;
}

export interface TestAttempt {
  testId: string;
  startedAt: string;
  completedAt?: string;
  answers: Record<string, string[]>; // questionId -> selected option ids
  score?: number;
  passed?: boolean;
  timeSpent?: number; // seconds
}

export interface TestProgress {
  testId: string;
  channelId: string;
  attempts: TestAttempt[];
  bestScore: number;
  lastAttemptAt?: string;
  passed: boolean;
}

// Storage keys
const TESTS_STORAGE_KEY = 'channel-tests';
const TEST_PROGRESS_KEY = 'test-progress';
const TEST_PROMPT_DISMISSED_KEY = 'test-prompt-dismissed';

// Get all available tests (loaded from static JSON)
let testsCache: Test[] | null = null;

export async function loadTests(): Promise<Test[]> {
  if (testsCache) return testsCache;
  
  try {
    const response = await fetch('/data/tests.json');
    if (!response.ok) return [];
    testsCache = await response.json();
    return testsCache || [];
  } catch {
    return [];
  }
}

// Get test for a specific channel
export async function getTestForChannel(channelId: string): Promise<Test | null> {
  const tests = await loadTests();
  return tests.find(t => t.channelId === channelId) || null;
}

// Get all test progress from localStorage
export function getAllTestProgress(): Record<string, TestProgress> {
  try {
    const stored = localStorage.getItem(TEST_PROGRESS_KEY);
    return stored ? JSON.parse(stored) : {};
  } catch {
    return {};
  }
}

// Get progress for a specific test
export function getTestProgress(testId: string): TestProgress | null {
  const all = getAllTestProgress();
  return all[testId] || null;
}

// Save test attempt
export function saveTestAttempt(testId: string, channelId: string, attempt: TestAttempt): void {
  const all = getAllTestProgress();
  
  if (!all[testId]) {
    all[testId] = {
      testId,
      channelId,
      attempts: [],
      bestScore: 0,
      passed: false,
    };
  }
  
  all[testId].attempts.push(attempt);
  all[testId].lastAttemptAt = attempt.completedAt;
  
  if (attempt.score !== undefined) {
    if (attempt.score > all[testId].bestScore) {
      all[testId].bestScore = attempt.score;
    }
    if (attempt.passed) {
      all[testId].passed = true;
    }
  }
  
  localStorage.setItem(TEST_PROGRESS_KEY, JSON.stringify(all));
}

// Calculate score for an attempt
export function calculateScore(test: Test, answers: Record<string, string[]>): { 
  score: number; 
  correct: number; 
  total: number;
  passed: boolean;
} {
  let correct = 0;
  const total = test.questions.length;
  
  test.questions.forEach(q => {
    const userAnswers = answers[q.id] || [];
    const correctOptions = q.options.filter(o => o.isCorrect).map(o => o.id);
    
    if (q.type === 'single') {
      // Single choice: exact match
      if (userAnswers.length === 1 && correctOptions.includes(userAnswers[0])) {
        correct++;
      }
    } else {
      // Multiple choice: all correct and no incorrect
      const allCorrectSelected = correctOptions.every(id => userAnswers.includes(id));
      const noIncorrectSelected = userAnswers.every(id => correctOptions.includes(id));
      if (allCorrectSelected && noIncorrectSelected && userAnswers.length > 0) {
        correct++;
      }
    }
  });
  
  const score = Math.round((correct / total) * 100);
  return { score, correct, total, passed: score >= test.passingScore };
}

// Shuffle array helper (Fisher-Yates)
function shuffleArray<T>(array: T[]): T[] {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

/**
 * Calculate semantic similarity between two questions using keyword matching
 */
function calculateQuestionSimilarity(q1: TestQuestion, q2: TestQuestion): number {
  let score = 0;

  // Same difficulty: +0.2
  if (q1.difficulty === q2.difficulty) {
    score += 0.2;
  }

  // Extract keywords from questions
  const keywords1 = extractKeywords(q1.question);
  const keywords2 = extractKeywords(q2.question);

  // Keyword overlap
  const commonKeywords = keywords1.filter(k => keywords2.includes(k));
  const keywordScore = commonKeywords.length / Math.max(keywords1.length, keywords2.length, 1);
  score += keywordScore * 0.5;

  // Question length similarity (prefer similar complexity)
  const lengthRatio = Math.min(q1.question.length, q2.question.length) / 
                      Math.max(q1.question.length, q2.question.length);
  score += lengthRatio * 0.3;

  return Math.min(score, 1.0);
}

/**
 * Extract keywords from question text
 */
function extractKeywords(text: string): string[] {
  const stopWords = new Set([
    'what', 'how', 'why', 'when', 'where', 'which', 'who',
    'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at',
    'to', 'for', 'of', 'with', 'by', 'from', 'is', 'are',
    'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had',
    'do', 'does', 'did', 'will', 'would', 'should', 'could',
    'can', 'may', 'might', 'must', 'shall'
  ]);

  return text
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, ' ')
    .split(/\s+/)
    .filter(word => word.length > 3 && !stopWords.has(word))
    .slice(0, 10);
}

/**
 * Determine target difficulty based on recent performance
 */
function determineTargetDifficulty(
  currentLevel: 'beginner' | 'intermediate' | 'advanced',
  recentAccuracy: number,
  totalAnswered: number
): 'beginner' | 'intermediate' | 'advanced' {
  // Start with beginner for first few questions
  if (totalAnswered < 2) return 'beginner';

  // If doing well (>70% accuracy), increase difficulty
  if (recentAccuracy > 0.7) {
    if (currentLevel === 'beginner') return 'intermediate';
    if (currentLevel === 'intermediate') return 'advanced';
    return 'advanced';
  }

  // If struggling (<40% accuracy), decrease difficulty
  if (recentAccuracy < 0.4) {
    if (currentLevel === 'advanced') return 'intermediate';
    if (currentLevel === 'intermediate') return 'beginner';
    return 'beginner';
  }

  // Otherwise maintain current level
  return currentLevel;
}

/**
 * Get progressive questions using RAG-based selection
 * Questions are selected based on semantic similarity and adaptive difficulty
 * 
 * IMPORTANT: Uses Set to track selected question IDs to prevent duplicates
 */
export function getSessionQuestions(test: Test, count: number = 20): TestQuestion[] {
  const maxCount = Math.min(count, test.questions.length);
  if (maxCount === 0) return [];

  const selectedQuestions: TestQuestion[] = [];
  const selectedIds = new Set<string>(); // Track selected question IDs to prevent duplicates
  let currentDifficulty: 'beginner' | 'intermediate' | 'advanced' = 'beginner';
  let performanceHistory: boolean[] = [];

  // Helper to get available questions (not yet selected)
  const getAvailable = () => test.questions.filter(q => !selectedIds.has(q.id));

  for (let i = 0; i < maxCount; i++) {
    const availableQuestions = getAvailable();
    if (availableQuestions.length === 0) break;

    let nextQuestion: TestQuestion;

    if (i === 0) {
      // First question: random beginner or intermediate
      const easyQuestions = availableQuestions.filter(
        q => q.difficulty === 'beginner' || q.difficulty === 'intermediate'
      );
      const pool = easyQuestions.length > 0 ? easyQuestions : availableQuestions;
      nextQuestion = pool[Math.floor(Math.random() * pool.length)];
    } else {
      // Calculate recent accuracy
      const recentPerformance = performanceHistory.slice(-3);
      const recentAccuracy = recentPerformance.length > 0
        ? recentPerformance.filter(Boolean).length / recentPerformance.length
        : 0.5;

      // Determine target difficulty
      const targetDifficulty = determineTargetDifficulty(
        currentDifficulty,
        recentAccuracy,
        i
      );
      currentDifficulty = targetDifficulty;

      // Filter by difficulty from available questions only
      const difficultyFiltered = availableQuestions.filter(
        q => q.difficulty === targetDifficulty
      );
      const candidatePool = difficultyFiltered.length > 0 
        ? difficultyFiltered 
        : availableQuestions;

      // Calculate similarity scores with previous question
      const previousQuestion = selectedQuestions[i - 1];
      const scored = candidatePool.map(q => ({
        question: q,
        score: calculateQuestionSimilarity(previousQuestion, q)
      }));

      // Sort by relevance and pick from top 5 to add variety
      scored.sort((a, b) => b.score - a.score);
      const topCandidates = scored.slice(0, Math.min(5, scored.length));
      nextQuestion = topCandidates[Math.floor(Math.random() * topCandidates.length)].question;
    }

    // Add to selected and mark as used
    selectedQuestions.push(nextQuestion);
    selectedIds.add(nextQuestion.id);

    // Simulate performance for next selection (assume 60% success rate)
    performanceHistory.push(Math.random() > 0.4);
  }

  // Randomize options for each question
  return selectedQuestions.map(q => ({
    ...q,
    options: shuffleArray(q.options)
  }));
}

// Check if test prompt was dismissed for a channel
export function isTestPromptDismissed(channelId: string): boolean {
  try {
    const stored = localStorage.getItem(TEST_PROMPT_DISMISSED_KEY);
    const dismissed = stored ? JSON.parse(stored) : {};
    return !!dismissed[channelId];
  } catch {
    return false;
  }
}

// Dismiss test prompt for a channel
export function dismissTestPrompt(channelId: string): void {
  try {
    const stored = localStorage.getItem(TEST_PROMPT_DISMISSED_KEY);
    const dismissed = stored ? JSON.parse(stored) : {};
    dismissed[channelId] = Date.now();
    localStorage.setItem(TEST_PROMPT_DISMISSED_KEY, JSON.stringify(dismissed));
  } catch {
    // Ignore
  }
}

// Generate shareable badge URL
export function generateShareableBadge(
  channelName: string,
  score: number,
  passed: boolean
): string {
  const badge = passed ? 'âœ…' : 'ðŸ“Š';
  const text = `${badge} I scored ${score}% on the ${channelName} test on Code Reels!`;
  const url = 'https://open-interview.github.io/';
  
  return `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`;
}

// Generate social share URL
export function generateSocialShare(
  channelName: string,
  score: number,
  passed: boolean
): string {
  const url = 'https://open-interview.github.io/';
  return `https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(url)}`;
}

// Get test stats summary
export function getTestStats(): {
  totalTests: number;
  passedTests: number;
  totalAttempts: number;
  averageScore: number;
} {
  const progress = getAllTestProgress();
  const entries = Object.values(progress);
  
  const totalTests = entries.length;
  const passedTests = entries.filter(p => p.passed).length;
  const totalAttempts = entries.reduce((sum, p) => sum + p.attempts.length, 0);
  
  const scores = entries.map(p => p.bestScore).filter(s => s > 0);
  const averageScore = scores.length > 0 
    ? Math.round(scores.reduce((a, b) => a + b, 0) / scores.length)
    : 0;
  
  return { totalTests, passedTests, totalAttempts, averageScore };
}
