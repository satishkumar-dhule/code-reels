[
  {
    "id": "fe-1",
    "question": "Explain the React Virtual DOM and Reconciliation process.",
    "answer": "Virtual DOM is a lightweight copy of the real DOM. Reconciliation is the sync process.",
    "explanation": "1. **Render**: React creates a Virtual DOM tree from components.\n2. **Diff**: When state changes, create a new VDOM tree and compare with the old one (Diffing Algorithm).\n3. **Patch**: Calculate the minimum number of changes needed and update the **Real DOM** in a batch.\n\n**Keys** help React identify which items have changed, added, or removed in lists, preventing unnecessary re-renders.",
    "tags": [
      "react",
      "perf",
      "internals"
    ],
    "difficulty": "intermediate",
    "channel": "frontend",
    "subChannel": "react",
    "diagram": "\nflowchart LR\n    State --> VDOM_New\n    VDOM_Old --> Diff\n    VDOM_New --> Diff{Diffing}\n    Diff --> Patch[Update Real DOM]\n",
    "lastUpdated": "2025-12-12T09:07:04.187Z"
  },
  {
    "id": "fe-2",
    "question": "What is the Event Loop in JavaScript? How do Microtasks differ from Macrotasks?",
    "answer": "The Event Loop coordinates the Call Stack, Web APIs, and Callback Queues.",
    "explanation": "JS is single-threaded.\n\n1. **Call Stack**: Executes sync code.\n2. **Microtask Queue**: Promises, MutationObservers. (Higher Priority - processed immediately after stack clears).\n3. **Macrotask Queue**: setTimeout, setInterval, I/O. (Processed one per loop tick).\n\n**Order**: Sync -> All Microtasks -> Render UI -> One Macrotask -> Repeat.",
    "tags": [
      "js",
      "async",
      "core"
    ],
    "difficulty": "beginner",
    "channel": "frontend",
    "subChannel": "javascript",
    "diagram": "\ngraph TD\n    Stack[Call Stack] -->|Empty?| CheckMicro{Microtasks?}\n    CheckMicro -->|Yes| RunMicro[Run All Microtasks]\n    RunMicro --> CheckMicro\n    CheckMicro -->|No| Render[Render UI]\n    Render --> RunMacro[Run One Macrotask]\n    RunMacro --> Stack\n",
    "lastUpdated": "2025-12-12T09:07:04.187Z"
  },
  {
    "id": "fe-3",
    "question": "Explain 'Closure' in JavaScript with a practical use case.",
    "answer": "A Closure is a function remembering its lexical scope even when executed outside that scope.",
    "explanation": "**Concept**: When a function returns another function, the inner function retains access to the outer function's variables.\n\n**Use Case: Data Privacy / Currying**\n```javascript\nfunction createCounter() {\n  let count = 0; // Private variable\n  return {\n    increment: () => count++,\n    get: () => count\n  };\n}\nconst c = createCounter();\nc.increment(); // 1\n// count is not accessible directly\n```",
    "tags": [
      "js",
      "scope",
      "patterns"
    ],
    "difficulty": "intermediate",
    "channel": "frontend",
    "subChannel": "javascript",
    "diagram": "\ngraph TD\n    Outer[Outer Function] --> Var[count = 0]\n    Outer --> Inner[Inner Function]\n    Inner -.->|Remembers| Var\n",
    "lastUpdated": "2025-12-12T09:07:04.187Z"
  }
]