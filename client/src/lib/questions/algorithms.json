[
  {
    "id": "al-1",
    "question": "When would you use a Linked List over an Array?",
    "answer": "Linked Lists excel at insertions/deletions, Arrays excel at random access.",
    "explanation": "**Array**:\n- Access: O(1) (Direct memory address)\n- Insert/Delete: O(n) (Shift elements)\n- Memory: Contiguous\n\n**Linked List**:\n- Access: O(n) (Traversal)\n- Insert/Delete: O(1) (Change pointer - if you have the node)\n- Memory: Scattered (Heap)\n\n**Use List when**: Implementing Queues, Stacks, or when memory is fragmented.",
    "tags": [
      "struct",
      "comparison",
      "basics"
    ],
    "difficulty": "beginner",
    "channel": "algorithms",
    "subChannel": "data-structures",
    "diagram": "\ngraph LR\n    subgraph Array\n    A1[0] --- A2[1] --- A3[2] --- A4[3]\n    end\n    subgraph LinkedList\n    L1[Node] --> L2[Node] --> L3[Node]\n    end\n",
    "lastUpdated": "2025-12-12T09:07:04.185Z"
  },
  {
    "id": "al-2",
    "question": "Explain QuickSort vs MergeSort. Which is better?",
    "answer": "QuickSort is generally faster in practice (cache locality) but unstable. MergeSort is stable but uses O(n) space.",
    "explanation": "**QuickSort**:\n- Avg: O(n log n), Worst: O(n^2) (bad pivot).\n- Space: O(log n) stack.\n- **In-place**.\n\n**MergeSort**:\n- Always O(n log n).\n- Space: O(n) (aux array).\n- **Stable** (preserves order of equals).\n\n**Verdict**: Arrays -> QuickSort. Linked Lists -> MergeSort.",
    "tags": [
      "sort",
      "recursion",
      "complexity"
    ],
    "difficulty": "intermediate",
    "channel": "algorithms",
    "subChannel": "sorting",
    "diagram": "\ngraph TD\n    A[Array] --> P{Pick Pivot}\n    P --> L[Left < Pivot]\n    P --> R[Right > Pivot]\n    L --> Sort1[Recurse]\n    R --> Sort2[Recurse]\n",
    "lastUpdated": "2025-12-12T09:07:04.185Z"
  },
  {
    "id": "al-3",
    "question": "What is Dynamic Programming? How is it different from Recursion?",
    "answer": "DP is Recursion + Optimization (Memoization/Tabulation).",
    "explanation": "Recursion solves subproblems blindly (potentially repeating work).\n\n**DP** stores the result of subproblems so you never solve the same problem twice.\n\n**Example**: Fibonacci.\n- Recursion: `fib(n-1) + fib(n-2)` -> O(2^n)\n- DP: Store `fib` array -> O(n)\n\n**Two Approaches**:\n1. Top-Down (Memoization)\n2. Bottom-Up (Tabulation)",
    "tags": [
      "dp",
      "optimization",
      "theory"
    ],
    "difficulty": "advanced",
    "channel": "algorithms",
    "subChannel": "dynamic-programming",
    "diagram": "\ngraph TD\n    P[Problem] --> S1[Subproblem 1]\n    P --> S2[Subproblem 2]\n    S1 --> C[(Cache)]\n    S2 --> C\n    C --> R[Result]\n",
    "lastUpdated": "2025-12-12T09:07:04.185Z"
  }
]